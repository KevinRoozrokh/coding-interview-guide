# coding-interview-guide
#### Coding Interview Preparation: A Comprehensive Guide for Noobs
Original articles posted at: 

Coding Interview Preparation for FAANG, MANGA, etc: A Comprehensive Study Guide to get an Offer Letter.

Introduction:
Preparing for coding interviews can be a daunting task, but with the right resources and strategies, you can boost your confidence and increase your chances of success. In this blog post, we will provide you with a curated list of coding interview preparation links that cover various aspects of the interview process, including LeetCode question sets, system design, behavioral interview tips, recommended books, online courses, and insightful blogs. Let’s dive in and get you ready for your coding interview journey!

[Real Salary Comps from Actual Job Offers]
When you land that job offer letter, use this website as your negotiation tool. Never accept the first offer, always negotiate, the people hiring will respect you more for knowing your worth.

(https://Levels.fyi)

LeetCode Question Sets:
1. [Google Online Assessment Questions](https://leetcode.com/discuss/interview-question/352460/Google-Online-Assessment-Questions)
2. [Amazon Online Assessment Questions](https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Questions)
3. [Curated List of Top 100 LeetCode Questions](https://www.teamblind.com/article/New-Year-Gift---Curated-List-of-Top-100-LeetCode-Questions-to-Save-Your-Time-OaM1orEU)
4. [60 LeetCode Questions to Prepare for Coding Interview](https://medium.com/@koheiarai94/60-leetcode-questions-to-prepare-for-coding-interview-8abbb6af589e)
5. [LeetCode Top 100 Problem Selection](https://h1ros.github.io/posts/coding/leetcode-top-100-problem-selection/)
6. [LeetCode Curation Topical](https://github.com/fterh/leetcode-curation-topical)
7. [LeetCode Top100](https://github.com/liuchuo/LeetCode-Top100)

System Design:
1. [System Design Template](https://leetcode.com/discuss/career/229177/My-System-Design-Template)
2. [System Design Primer](https://github.com/donnemartin/system-design-primer)
3. [Grokking the System Design Interview](https://www.educative.io/courses/grokking-the-system-design-interview) (*paid course)
4. [System Design Interview — An Insider’s Guide](https://www.youtube.com/watch?v=iJLL-KPqBpM)

Behavioral/Deep-Dive:
1. [Cracking the Coding Interview: Behavioral Questions](https://www.youtube.com/watch?v=PJKYqLP6MRE)
2. [Amazon’s Official Interview Guide](https://www.amazon.jobs/en/landing_pages/in-person-interview)

General Interview Resources:
1. [Careercup](https://www.careercup.com/)
2. [Glassdoor](https://www.glassdoor.com/index.htm)
3. [Catalog of all FAANG interview information on Rooftop Slushie](https://www.teamblind.com/article/Catalog-of-FAANG-interview-information-MRLji71n)
4. [freeCodeCamp](https://www.freecodecamp.org/)

Books:
1. [Cracking the Coding Interview by Gayle Laakmann McDowell](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850/) (6th edition)
2. [Computer Science Distilled](https://www.amazon.com/Computer-Science-Distilled-Computational-Problems/dp/0997316020)
3. [Distributed Systems for Fun and Profit](http://book.mixu.net/distsys/)
4. [Designing Data Intensive Applications by Martin Kleppman](https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321)
5. [The Google Resume by Gayle Laakmann McDowell](https://www.amazon.com/Google-Resume-Preparation-Mastering-Interview/dp/0470927623)
6. [Programming Interviews Exposed by John Mongan, Noah Suojanen](https://www.amazon.com/Programming-Interviews-Exposed-Secrets-Landing/dp/111941847X)
7. [Elements of Programming Interviews by Adnan Aziz, Tsung-Hsien Lee, Amit Prakash](https://www.amazon.com/Elements-Programming-Interviews-Python-Insiders/dp/1537713949)

Courses:
1. [Grokking the System Design Interview](https://www.educative.io/courses/grokking-the-system-design-interview) (*paid course)
2. [Grokking Dynamic Programming Patterns for Coding Interviews](https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews) (*paid course)
3. [MIT OpenCourseWare: Introduction to Algorithms](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/)
4. [YouTube Playlist: Algorithms and Data Structures](https://www.youtube.com/watch?v=y62zj9ozPOM&list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu)

Blogs:
1. Netflix Tech Blog — [Medium](https://medium.com/netflix-techblog)
2. Uber Engineering Blog — [Website](https://eng.uber.com/)
3. Twitter Engineering Blog — [Website](https://blog.twitter.com/engineering/en_us.html)
4. Airbnb Engineering Blog — [Medium](https://medium.com/airbnb-engineering) and [Website](https://airbnb.io/)
5. Here’s a consolidated list of company-wise engineering blogs: [GitHub](https://github.com/kilimchoi/engineering-blogs)
6. [Outco Blog](https://medium.com/outco)
7. [Liyin’s Blog](https://medium.com/@liyin2015)
8. [Sourab Reddy’s Blog](https://medium.com/@sourabreddy)
9. [GeeksforGeeks](https://www.geeksforgeeks.org/)
10. [Awesome GitHub Repository](https://github.com/sindresorhus/awesome)
11. [Algorithms and Coding Interviews by Liyin](https://github.com/liyin2015/Algorithms-and-Coding-Interviews)
12. [LeetCode Patterns](https://medium.com/leetcode-patterns)
13. [14 Patterns to Ace Any Coding Interview Question](https://hackernoon.com/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed)
14. [Program Creek](https://www.programcreek.com/2012/11/top-10-algorithms-for-coding-interview/)

YouTube Channels/Playlists:
1. [Back to Back SWE](https://www.youtube.com/channel/UCmJz2DV1a3yfgrR7GqRtUUA/playlists)
2. [Tushar Roy](https://www.youtube.com/user/tusharroy2525/playlists)
3. [happygirlzt](https://www.youtube.com/user/happygirlzt)
4. [Nick White’s LeetCode Explanations](https://www.youtube.com/playlist?list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp-)
5. [mycodeschool](https://www.youtube.com/user/mycodeschool/playlists)
6. [Tech Dummies](https://www.youtube.com/channel/UCn1XnDWhsLS5URXTi5wtFTA/playlists)
7. [CS Dojo](https://www.youtube.com/channel/UCxX9wt5FWQUAAz4UrysqK9A/playlists)
8. [Network Chuck](https://www.youtube.com/@NetworkChuck)

Intro to CS:
1. [Open Source Society University — Computer Science](https://github.com/ossu/computer-science)
2. [Open Source CS](https://github.com/ForrestKnight/open-source-cs)
3. [Upskill Courses: Essential Web Developer Course](https://upskillcourses.com/courses/essential-web-developer-course)

Conclusion:
With this organized list of coding interview preparation resources, you now have a wealth of information at your fingertips. Remember, practice is key, so make sure to solve coding problems regularly, study system design concepts, and enhance your behavioral interview skills. Stay motivated, stay focused, and best of luck with your coding interviews!

---

#### Demystifying Big O Notation: Why Every Software Engineer Should Master It for Coding Interviews

Understanding Big O Notation: A Crucial Concept for Coding Interviews.

Big O is especially important at FAANG or MANNG coding interviews.

Introduction:
In the world of software engineering, efficiency and scalability are key factors when designing and analyzing algorithms. Big O notation, a mathematical concept, allows us to express the time and space complexity of algorithms, helping us understand their efficiency and performance. In this blog post, we will dive into the significance of Big O notation, its relevance in coding interviews, and provide definitions for various complexity levels. We’ll also explore the concepts of upper bounds and lower bounds. To help grasp the concept, we’ll use a metaphor comparing Big O notation to a food recipe and the variable ’n’ to the number of times you follow the recipe.

Why Big O Notation Matters in Coding Interviews:
During coding interviews, candidates are evaluated not only on their ability to write correct code but also on their understanding of algorithmic efficiency. Employers seek engineers who can create scalable solutions that can handle large data sets efficiently. Big O notation helps quantify the performance of algorithms and enables engineers to make informed decisions when choosing the most suitable approach for a given problem. It demonstrates an engineer’s ability to optimize code and assess the trade-offs between time complexity and space complexity.

Definitions of Big O Notation Complexities:
1. Constant Time (O(1)): An algorithm with constant time complexity executes in the same amount of time regardless of the input size. It is the most efficient complexity level. Example: Accessing an element from an array with a known index.

2. Logarithmic Time (O(log n)): Algorithms with logarithmic time complexity have a runtime proportional to the logarithm of the input size. They efficiently divide the problem space in each step. Example: Binary search in a sorted array.

3. Linear Time (O(n)): Algorithms with linear time complexity have a runtime that scales linearly with the input size. The execution time grows proportionally to the number of elements. Example: Iterating through an array to find a specific element.

4. Log Linear Time (O(n log n)): Algorithms with log linear time complexity are slightly more complex than linear time algorithms. They have a runtime proportional to the product of the input size and the logarithm of the input size. Example: Merge sort, quicksort.

5. Quadratic Time (O(n²)): Algorithms with quadratic time complexity have a runtime proportional to the square of the input size. They involve nested iterations over the input data. Example: Bubble sort, selection sort.

6. Cubic Time (O(n³)): Algorithms with cubic time complexity have a runtime proportional to the cube of the input size. They involve three nested iterations over the input data. Example: Nested loops with three levels.

7. Exponential Time (O(2^n)): Algorithms with exponential time complexity have a runtime that doubles with each additional input element. They become highly inefficient for larger input sizes. Example: Generating all possible subsets of a set.

8. Factorial Time (O(n!)): Algorithms with factorial time complexity have a runtime that grows factorially with the input size. They are highly inefficient and typically not feasible for most practical applications. Example: Generating all possible permutations of a set.

Understanding Upper Bounds and Lower Bounds:
In the context of Big O notation, upper bounds and lower bounds provide additional insights into the algorithm’s performance:

- Upper Bounds: The upper bound of an algorithm’s time complexity represents the worst-case scenario or the maximum time required to solve a problem. It provides an assurance that the algorithm will not take more time than indicated by the upper bound. Big O notation represents the upper bound.

- Lower Bounds: The lower bound of an algorithm’s time complexity represents the best-case scenario or the minimum time required to solve a problem. It gives a lower limit on the time taken by an

algorithm. Lower bounds are usually represented using Ω (omega) notation.

Metaphor: Big O Notation as a Food Recipe
To understand Big O notation, imagine a food recipe. Let’s say you want to make a cake. The recipe represents an algorithm, and ’n’ represents the number of times you follow the recipe. The complexity of the recipe can be described using Big O notation. For example:

- If the recipe states, “Mix ingredients in a bowl” (constant time), it means it will take the same amount of time, regardless of the number of times you follow the recipe.

- If the recipe states, “Cut fruits into half” (logarithmic time), it means the time taken will increase slightly with each additional fruit you cut.

- If the recipe states, “Peel ’n’ potatoes” (linear time), the time taken will increase linearly with the number of potatoes you need to peel.

Conclusion:
Big O notation is a crucial concept for software engineers, particularly during coding interviews. Understanding algorithmic complexity and efficiency is essential for designing scalable solutions. By using Big O notation, engineers can quantify the performance of their algorithms and make informed decisions. Remember, just as a recipe’s complexity can vary based on the number of times you follow it, the time complexity of an algorithm can change based on the size of the input. Keep practicing and honing your understanding of Big O notation to excel in coding interviews and become a proficient software engineer.

Written by Kevin K. Roozrokh
Follow me on the socials:
https://linktr.ee/kevin_roozrokh
Portfolio: https://KevinRoozrokh.github.io
